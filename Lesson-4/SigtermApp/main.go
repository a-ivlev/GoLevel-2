/*
Написать программу, которая при получении в канал сигнала SIGTERM останавливается не
позднее, чем за одну секунду (установить таймаут).
*/

// SigtermApp при получении в канал сигнала SIGTERM останавливается не
// позднее, чем за одну секунду.
package main

import (
	"context"
	"fmt"
	"time"

	"os"
	"os/signal"
)

func main() {
	// Создаём контекст с функцией cancelFunc.
	ctx, cancelFunc := context.WithCancel(context.Background())
	// Создаём канал в который будем передавать считанный операционной системой сигнал Ctrl+C.
	ch := make(chan os.Signal)
	// Считываем сигнал операционной системы Ctrl+C и передаём в канал.
	signal.Notify(ch, os.Interrupt)
	// Создаём тикер который будет отправлять в специальный канал тик, через определённый промежуток времени.
	ticker := time.NewTicker(time.Second)
	// Запускаем бесконечный цикл в котором раз в секунду будем печатать в консоль текущее время,
	// пока не будет получен сигнал завершения программы Interrupt.
	for {
		select {
		// Получаем тик через заданный промежуток времени.
		case <-ticker.C:
			// Печатаем в консоль текущее время.
			fmt.Println("Московское время:", time.Now().Format("15-04-05"))
		// Получаем из канала сигнал завершения программы.
		case <-ch:
			// Создаём контекст с таймаутом и функцией завершения.
			ctx, cancelFunc = context.WithTimeout(ctx, time.Second)
			// Запускаем функцию завершения работы программы.
			cancelFunc()
		// Получаем из контекста сигнал завершения работы программы.
		case <-ctx.Done():
			fmt.Println("Программа завершена!")
			// Если вместо return поставить команду break, то получим бесконечный цикл вывода сообщения в консоль.
			return
		}
	}
}
